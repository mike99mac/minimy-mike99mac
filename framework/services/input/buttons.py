#
# This code is distributed under the Apache License, v2.0
#
"""
 Trap when GPIO pins 17, 27 and 22 are pressed and pass messages on to Minimy

 GPIO pin layout - odd pins are toward the inside of the Pi:
  '!' shows the pins used
       3V3  (1)  (2)  5V
     GPIO2  (3)  (4)  5V
     GPIO3  (5)  (6)  GND
     GPIO4  (7)  (8)  GPIO14
       GND  (9)! (10) GPIO15
    GPIO17 (11)! (12) GPIO18
    GPIO27 (13)! (14) GND
    GPIO22 (15)! (16) GPIO23
       3V3 (17)  (18) GPIO24
    GPIO10 (19)  (20) GND
     GPIO9 (21)  (22) GPIO25
    GPIO11 (23)  (24) GPIO8
       GND (25)  (26) GPIO7
     GPIO0 (27)  (28) GPIO1
     GPIO5 (29)  (30) GND
     GPIO6 (31)  (32) GPIO12
    GPIO13 (33)  (34) GND
    GPIO19 (35)  (36) GPIO16
    GPIO26 (37)  (38) GPIO20
       GND (39)  (40) GPIO21
  ----------------------------------------------------------------------
  TODO: add code so we can trap arrow key presses on the Raspberry Pi 400 keyboard
  
  How to get stdin to buttons.py process while in the background:

      You could start you server with a named pipe (fifo) as its input:

        mkfifo /tmp/srv-input
        cat > /tmp/srv-input &
        echo $! > /tmp/srv-input-cat-pid
        cat /tmp/srv-input | myserver &

      The cat > /tmp/srv-input & is important to avoid your server to receive a EOF. 
      At least one process must have the fifo opened in writing so your server does not receive a EOF. 
      The PID of this command is saved in the /tmp/srv-input-cat-pid file for latter kill.

  Code generated by ChatGPT:

  import keyboard

  def arrow_handler(e):
      if e.name == 'up':
          print("Up arrow key pressed")
      elif e.name == 'down':
          print("Down arrow key pressed")
      elif e.name == 'right':
          print("Right arrow key pressed")
      elif e.name == 'left':
          print("Left arrow key pressed")

  keyboard.on_press(arrow_handler)

  # Keep the program running
  keyboard.wait('esc')
  ----------------------------------------------------------------------
  """
from bus.Message import Message
from bus.MsgBusClient import MsgBusClient
from framework.util.utils import LOG
import os
import RPi.GPIO as GPIO
from skills.sva_base import SimpleVoiceAssistant
import signal
import subprocess
import sys
import time
from threading import Event
# import threading 
from framework.message_types import (MSG_UTTERANCE, MSG_MEDIA, MSG_SKILL, MSG_SYSTEM)

class Buttons(SimpleVoiceAssistant):  
  """
  Trap when buttons are pressed and perform 'previous', 'pause/resume' or 'next' actions
  """
  prev_button: int
  stop_button: int
  next_button: int
  message:     Message

  def __init__(self):
    self.skill_id = 'button_service'
    super().__init__(skill_id='button_service', skill_category='media')
    log_filename = "skills.log"
    self.log = LOG(log_filename).log
    self.log.debug(f"Buttons.__init__() log_filename: {log_filename}")
    self.prev_button = 17
    self.stop_button = 27
    self.next_button = 22
    self.last_pinval = 0
    self.locked = False
    self.button_start_time = None
    self.press_duration = 0

  def monitor_buttons(self):
    """
    For the "next" and "previous" buttons, it doesn't matter how long they are pushed
    so a button release can be detected.
    -----
    NOTE: cannot get the middle button to work as such:
    -----
    For the middle button, if it's pushed for more than 2 seconds, it's a "stop"
    which clear's the music queue, otherwise it's a toggle between pause and resume.
    """
    self.log.debug("Buttons.monitor_buttons()")
    GPIO.setmode(GPIO.BCM)                 # set GPIO numbering
    GPIO.setup(self.prev_button, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    GPIO.setup(self.stop_button, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    GPIO.setup(self.next_button, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    GPIO.add_event_detect(self.prev_button, GPIO.FALLING, callback=self.next_or_prev_pin, bouncetime=300)
    GPIO.add_event_detect(self.stop_button, GPIO.FALLING, callback=self.read_stop_pin, bouncetime=300)
    GPIO.add_event_detect(self.next_button, GPIO.FALLING, callback=self.next_or_prev_pin, bouncetime=300)
    signal.signal(signal.SIGINT, self.signal_handler)
    signal.pause()

  def signal_handler(self, sig, frame):
    """
    Trap Ctrl-C and cleanup before exiting
    """
    self.log.debug(f"Buttons.signal_handler() sig: {sig} frame: {frame}") 
    GPIO.cleanup()
    sys.exit(0)

  def send_message(self, verb):
    """
    Send a message to the bus with either "next", "previous", "pause" or "stop"
    """
    self.log.debug(f"Buttons.send_message() verb: {verb}")
    print(f"Buttons.send_message() verb: {verb}")
    info = { 
	          'subtype': 'oob_detect',
		        'skill_id': 'media_skill',
		        'from_skill_id': self.skill_id,
		        'verb': verb
           }    
    self.bus.send(MSG_SKILL, "media_skill", info)
    
  def read_stop_pin(self, *args):
    """
    Save when stop button was pressed, then when released if more than 2 seconds do a stop, otherwise pause/resume 
    If it's pressed briefly (shorter than bouncetime?), this is only called once, otherwise it's called twice
    """
    pinval = GPIO.input(self.stop_button)
    print(f"read_stop_pin() pinval: {pinval} lastpinval: {self.last_pinval}")
    self.send_message("pause")
    self.lastpinval = pinval
    return                                 # short circuit rest of the code

    if ((pinval == 0 and self.last_pinval == 0) or (pinval == 1 and self.last_pinval == 1)): # button was pushed and held
      print("read_stop_pin() stop button was pushed")
      self.button_start_time = time.time() # save time it was pushed
    elif ((pinval == 0 and self.last_pinval == 1) or (pinval == 1 and self.last_pinval == 0)): # button was released
      if self.button_start_time == None:   # button was pushed briefly
        print("read_stop_pin() stop button was pushed briefly - sending 'pause'")
        self.send_message("pause")
      else:  
        self.press_duration = time.time() - self.button_start_time
        print(f"read_stop_pin() pinval has changed from {self.last_pinval} to {pinval} duration = {self.press_duration}")
        if self.press_duration > 2.0:      # more than 2 seconds => stop
          self.send_message("stop")
        else:                              # pause toggles between pause and resume
          self.send_message("pause")  
      self.button_start_time = None

  def next_or_prev_pin(self, channel):
    """
    Perform action when either "previous" or "next" buttons is released
    """
    self.log.debug(f"Buttons.next_or_prev_pin() channel: {channel}") 
    match channel:
      case self.prev_button:
        self.log.debug(f"Buttons.next_or_prev_pin() previous")
        self.send_message("previous")
      case self.next_button:
        self.log.debug(f"Buttons.next_or_prev_pin() next")
        self.send_message("next")
      case _:                              # not expected
        self.log.error(f"Buttons.next_or_prev_pin() UNEXPECTED channel: {channel}")

# main()
if __name__ == '__main__':
    buttons = Buttons()
    buttons.monitor_buttons()
    Event().wait()                         # Wait forever
